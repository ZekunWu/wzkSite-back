### 浏览器缓存
浏览器缓存保存着用户通过 HTTP 获取的所有资源，在下一次请求时可以避免重复向服务器发出多余的请求。

一般来说浏览器缓存可以分为两类：
- 强缓存
- 协商缓存（对比缓存）

#### 强缓存
浏览器在加载资源时，会先根据本地缓存资源的 header 中的信息判断是否命中强缓存，如果命中则直接使用缓存中的资源不会再向服务器发送请求。
![avatar](https://mmbiz.qpic.cn/mmbiz_png/j3vcKBBdH46gEGrNj33aKfAoWXzuPhFwuhcAHTEc5ciaq8GZorWDQhn9mWiasWQLqiaDZeR3WBd5Blhvml6oBmsPQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
- 1.查看 header 头中的 Expire 和 Cache-control 来判断是否满足规则；
- 2.如果满足规则，就返回缓存的数据；
- 3.如果不满足规则，就向服务器发送请求；
- 4.服务器返回数据；
- 5.将新数据存入缓存。

##### Expires
这个字段包含了一个时间，过了这个时间，响应将会失效。

Expires:Fri, 27 Oct 2017 07:55:30 GMT

通过设置 Expire 来设置缓存有一个致命缺点：
可以看出，这个是个绝对时间，也就是说，如果我修改了客户端的本地时间，是不是就会导致判断缓存失效了呢。
##### Cache-Control
既然不能设置绝对时间，那我就设置个相对时间呗。

在 HTTP/1.1 中，增加了一个字段 Cache-Control ，它包含一个 max-age 属性，该字段表示资源缓存的最大有效时间，这就是一个相对时间。


Cache-Control:max-age=600

现在基本上都会同时设置 Expire 和 Cache-Control ，Cache-Control 的优先级别更高。

#### 协商缓存
当强缓存没有命中的时候，浏览器会发送一个请求到服务器，服务器根据请求头中的部分信息来判断是否命中缓存。如果命中，则返回 304 ，告诉浏览器资源未更新，可使用本地的缓存。
![avatar](https://mmbiz.qpic.cn/mmbiz_png/j3vcKBBdH46gEGrNj33aKfAoWXzuPhFw7eLia7lb2a0r0nnZ01kQSST6k4WHK0VuPbqLVwibE6znVF84I4F43IjA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)
- 1.把资源标识，比如 If-Modify-Since 或 Etag 发送到服务器，确认资源是否更新；
- 2.如果资源未更新，请求响应返回的http状态为 304 并且会显示一个 Not Modified 的字符串，告诉浏览器使用本地缓存;
- 3.如果资源已经更新，返回新的数据；
- 4.将新数据存入缓存。

##### Last-Modified，If-Modified-Since
浏览器第一次请求资源的时候，服务器返回的 header 上会带有一个 Last-Modified 字段，表示资源最后修改的时间。

Last-Modified: Fri, 27 Oct 2017 07:55:30 GMT

同样的，这是一个 GMT 的绝对时间。

当浏览器再次请求该资源时，请求头中会带有一个 If-Modified-Since 字段，这个值是第一次请求返回的 Last-Modified 的值。服务器收到这个请求后，将 If-Modified-Since 和当前的 Last-Modified 进行对比。如果相等，则说明资源未修改，返回 304，浏览器使用本地缓存。

well，这个方法也是有缺点的：

最小单位是秒。也就是说如果我短时间内资源发生了改变，Last-Modified 并不会发生变化；
周期性变化。如果这个资源在一个周期内修改回原来的样子了，我们认为是可以使用缓存的，但是 Last-Modified 可不这样认为。
所以，后来又引入一个 Etag。

###### Etag
Etag 一般是由文件内容 hash 生成的，也就是说它可以保证资源的唯一性，资源发生改变就会导致 Etag 发生改变。

同样地，在浏览器第一次请求资源时，服务器会返回一个 Etag 标识。当再次请求该资源时， 会通过 If-none-match 字段将 Etag 发送回服务器，然后服务器进行比较，如果相等，则返回 304 表示未修改。

Last-Modified 和 Etag 是可以同时设置的，服务器会优先校验 Etag，如果 Etag 相等就会继续比对 Last-Modified，最后才会决定是否返回 304。

#### 总结
当浏览器再次访问一个已经访问过的资源时，它会这样做：

- 1.看看是否命中强缓存，如果命中，就直接使用缓存了；<br>
- 2.如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存；<br>
- 3.如果命中协商缓存，服务器会返回 304 告诉浏览器使用本地缓存；<br>
- 4.否则，返回最新的资源。

内存缓存(from memory cache)和硬盘缓存(from disk cache)，如下:

   >内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性：
    
   >快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。
        
   >时效性：一旦该进程关闭，则该进程的内存则会清空。

   >硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。
    
在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。

为什么CSS会放在硬盘缓存中？
因为CSS文件加载一次就可渲染出来,我们不会频繁读取它,所以它不适合缓存到内存中,但是js之类的脚本却随时可能会执行,如果脚本在磁盘当中,我们在执行脚本的时候需要从磁盘取到内存中来,这样IO开销就很大了,有可能导致浏览器失去响应。

##### index.html的缓存策略
index.html 正是靠 etag 和 last-modified 来保证正确读取的。css 和 js 不用是因为  etag 和 last-modified 还是会请求一次服务器，比 cache-control  和 expires 直接读取本地缓存要慢一些。我们一般保证入口 html 文件能正确更新就行，css 和 js 都是在入口 html 文件引入的，并通过 Expires 和 Cache-Control 控制缓存有效期，其 url 中都带有 hash 的，如果这些 css 和 js 内容不变， 引用的 url 还是老的， 在缓存有效期内，浏览器直接读取本地缓存，如果内容变了，就是新的 url， 浏览器会重新请求资源。这样既高效利用了 http 缓存，又能保证资源的正确更新。


### 本地存储
#### Cookie
Cookie主要是由服务器生成，且前端也可以设置，保存在客户端本地的一个文件，通过response响应头的set-Cookie字段进行设置，且Cookie的内容自动在请求的时候被传递给服务器。
```
[HTTP/1.1 200 OK]
Server:[bfe/1.0.8.18]
Etag:["58860415-98b"]
Cache-Control:[private, no-cache, no-store, proxy-revalidate, no-transform]
Connection:[Keep-Alive]
Set-Cookie:[BDORZ=27315; max-age=86400; domain=.baidu.com; path=/]
Pragma:[no-cache]
Last-Modified:[Mon, 23 Jan 2017 13:24:37 GMT]
Content-Length:[2443]
Date:[Mon, 09 Apr 2018 09:59:06 GMT]
Content-Type:[text/html]
```
Cookie包含的信息：<br>
它可以记录你的用户ID、密码、浏览过的网页、停留的时间等信息。当你再次来到该网站时，网站通过读取Cookies，得知你的相关信息，就可以做出相应的动作，如在页面显示欢迎你的标语，或者让你不用输入ID、密码就直接登录等等。一个网站只能读取它自己放置的信息，不能读取其他网站的Cookie文件。因此，Cookie文件还保存了host属性，即网站的域名或ip。
这些属性以名值对的方式进行保存，为了安全，它的内容大多进行了加密处理。Cookie文件的命名格式是：用户名@网站地址[数字].txt

Cookie的优点：<br>
- 给用户更人性化的使用体验，如记住“密码功能”、老用户登录欢迎语
- 弥补了HTTP无连接特性
- 站点统计访问人数的一个依据

Cookie的缺点：<br>
- 它无法解决多人共用一台电脑的问题，带来了不安全因素
- Cookie文件容易被误删除
- 一人使用多台电脑
- Cookies欺骗。修改host文件，可以非法访问目标站点的Cookie
- 容量有限制，不能超过4kb
- 在请求头上带着数据安全性差
#### localStorage
> localStorage 和 sessionStorage都属于Web Storage

localStorage主要是前端开发人员，在前端设置，一旦数据保存在本地后，就可以避免再向服务器请求数据，因此减少不必要的数据请求，减少数据在浏览器和服务器间不必要地来回传递。

可以长期存储数据，没有时间限制，一天，一年，两年甚至更长，数据都可以使用。
localStorage中一般浏览器支持的是5M大小，这个在不同的浏览器中localStorage会有所不同

优点：
- localStorage拓展了cookie的4k限制
- localStorage可以将第一次请求的5M大小数据直接存储到本地，相比于cookie可以节约带宽
- localStorage的使用也是遵循同源策略的，所以不同的网站直接是不能共用相同的localStorage

缺点：
- 需要手动删除，否则长期存在
- 浏览器大小不一，版本的支持也不一样
- localStorage只支持string类型的存储，JSON对象需要转换
- localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡
#### sessionStorage
sessionStorage主要是前端开发人员，在前端设置，sessionStorage（会话存储），只有在浏览器被关闭之前使用，创建另一个页面时同样可以使用，关闭浏览器之后数据就会消失

存储上限限制：不同的浏览器存储的上限也不一样，但大多数浏览器把上限限制在5MB以下
#### websql
Web SQL 是在浏览器上模拟数据库，可以使用JS来操作SQL完成对数据的读写。它使用 SQL 来操纵客户端数据库的 API，这些 API 是异步的，规范中使用的方言是SQLlite。数据库还是在服务端，不建议使用，已废弃
#### indexedDB
随着浏览器的功能不断增强，越来越多的网站开始考虑，将大量数据储存在客户端，这样可以减少从服务器获取数据，直接从本地获取数据。

现有的浏览器数据储存方案，都不适合储存大量数据：Cookie 的大小不超过4KB，且每次请求都会发送回服务器；LocalStorage 在 2.5MB 到 10MB 之间（各家浏览器不同），而且不提供搜索功能，不能建立自定义的索引。所以，需要一种新的解决方案，这就是 IndexedDB 诞生的背景。

通俗地说，IndexedDB 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。这些都是 LocalStorage 所不具备的。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。

#### 清除缓存的方式
https://www.cnblogs.com/calamus/p/7615312.html